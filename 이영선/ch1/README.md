# 1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

## 1-1. 역사의 흐름은 무엇인가?
- 자바 8에서 제공하는 새로운 기술
  - 스트림 API : 병렬 연산을 지원 
    
    (고수준 언어로 동작 표현 → 최적의 저수준 실행 방법을 선택, 실행)
  - 메서드에 코드를 전달하는 기법 : 메서드 참조와 람다 
    
    → 새롭고 간결한 방식으로 **동적 파라미터화**를 구현할 수 있다 (익명 클래스를 이용할 때보다 더 간단 명료!)
    
    → **함수형 프로그래밍**에서 많이 사용
  - 인터페이스의 디폴트 메서드


- 자바 8을 사용하면 좋은 점 
  - 자연어에 더 가깝게 간단한 코드를 구현할 수 있다. 
  - 병렬 실행을 새롭고 단순한 방식으로 구현할 수 있다.
  - 기존의 객체지향 프로그래밍에 함수형 프로그래밍을 도입하여 문제를 더 다양한 방식으로 해결할 수 있게 되었다.

## 1-2. 왜 아직도 자바는 변화하는가?
- 초반 자바
  - 잘 설계된 객체 지향 언어
  - 스레드와 락을 이용한 동시성 지원
- 위기 : 빅데이터를 효과적으로 처리하기 위해 병렬 프로세싱을 활용해야 했다. (자바는 불가능했음)
   
    → 해결책 : 자바 8의 새로운 기능들

### 1. 스트림 처리 (stream processing)
- 스트림 : 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임

  (어떤 항목을 연속으로 제공하는 어떤 기능)

- 한 번에 한 항목만 처리하던 기존 방식 --(스트림)→ 작업을 고수준으로 추상화하여 일련의 스트림으로 만들어 일괄 처리 가능

- 공짜 병렬성 GET~! 

    (스트림 파이프라인을 통해 입력 부분을 여러 CPU 코어에 쉽게 할당)
- `java.util.stream` 패키지에 스트림 API가 추가되었다.

    `Stream <T>` : T 형식으로 구성된 일력의 항목

### 2. 동적 파라미터화로 메서드에 코드 전달하기 (behavior parameterization)
- 동적 파라미터화
  - 코드 일부를 API로 전달하는 기능
  - 메서드를 다른 메서드의 인수로 넘겨주는 기능 
  - ex. sort의 동작(정렬 기준)을 구현한 메서드를 `sort()` 메서드의 인수로 넘겨준다

### 3. 병렬성과 공유 가변 데이터
- 스트림 메서드로 전달하는 코드의 동작 방식을 바꾸면 **병렬성**을 얻을 수 있다!
  
  = 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다.
    
  = 공유된 가변 데이터에 접근하면 안된다.

## 1-3. 자바 함수
- 함수(function) = 정적 메서드(static method) 
- 함수를 값처럼 취급한다. = 메서드를 일급 시민으로 사용한다.

  (**함수**를 병렬 프로그래밍을 활용하는 **스트림**과 연계하기 위해서)
<details>
  <summary>일급 시민과 이급 시민</summary>
  
- 일급 시민 = 일급 값 = first-class
  - 자바의 데이터(primitive type, reference type), 람다식, 익명 클래스 등이 여기에 포함된다.
  - 일급 객체의 조건
    1. 모든 일급 객체는 변수나 데이터에 담을 수 있어야 한다. 
    2. 모든 일급 객체는 함수의 파라미터로 전달 할 수 있어야 한다.
    3. 모든 일급 객체는 함수의 리턴값으로 사용 할 수 있어야 한다.
- 이급 시민 = 이급 값
  - 전달할 수 없는 구조체를 의미한다.
  - 자바의 메서드와 클래스 등이 이에 해당한다.

- [레퍼런스](https://inpa.tistory.com/entry/CS-%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4first-class-object)

</details>


### 메서드를 값처럼 참조하기 위한 자바 8의 새로운 기능
1. 메서드 참조 (method reference, `::`)
   - `::` : '이 메서드를 값으로 사용하라'는 의미이다.
   - 메서드를 일급값으로 취급
> Q. 값으로 사용 가능한 메서드 == `함수` , 아닌 메서드(이급 시민인 메서드) == `메서드` 인가?
2. 람다 = 익명함수 (anonymous functions)
   - 람다를 사용하여 함수를 일급값으로 넘겨줄 수 있다.
   - ex. `(int x) -> x+1` : x라는 인수를 호출하면 x+1을 반환하라

### [사과 필터 예제](https://github.com/StudyRecords/modern-java-in-action/blob/main/src/main/java/ch1/AppleFilter.java)
- `filter` : 특정 항목을 선택해서 반환하는 동작
- 무게와 색깔처럼 다른 기준으로 사과를 filtering 하고 싶다면, 자바8 이전에는 코드를 복붙해야 했다.
    
  → 코드 중복 문제 발생

  
- sol 1. 메서드 참조 사용
  - `pre` 라는 이름의 파라미터로 `test()` **메서드가 전달**된다.
    - Predicate : 인수로 값을 받아 true 나 false 를 반환하는 함수
  - 단점 : 한두 번만 사용할 메서드를 매번 정의해야 한다.
- sol 2. 람다 표현식 사용
  - 장점 : 메서드의 정의를 따로 구현할 필요가 없다. 짧고 간결하다.
  - 단점 : 복잡한 동작을 수행하는 메서드를 정의할 때에는 메서드 참조 방식을 사용하는 것이 좋다 (해당 일을 설명하는 이름을 가진 메서드를 정의하라)
- sol 3. 스트림 사용
  - 스트림을 사용하면 `filterApples()` 메서드를 직접 구현할 필요 없이, stream 라이브러리의 `filter()` 메서드를 사용하면 된다.
  ```java
  public interface Stream<T> extends BaseStream<T, Stream<T>> { 
        
        Stream<T> filter(Predicate<? super T> predicate);
  }
  ```
- 코드 예시
  ```java
  // 1. 메서드 참조 사용 (Apple 클래스 내에 정의된 static 메서드 isGreen 사용)
  List<Apple> greenApples = filterApples(inventory, Apple::isGreen); 
  
  // 2. 람다 표현식 사용
  List<Apple> greenApples2 = filterApples(inventory, (Apple apple) -> GREEN.equals(apple.getColor()));
  
  // 3. 스트림 사용
  List<Apple> streamApples = inventory.stream()
        .filter((Apple apple) -> GREEN.equals(apple.getColor()))
        .toList();
  ```
> Q. 함수는 왜 필요할까?

> Q. 코드 세번째 예시에서 마지막줄 `.collect(toList())` 와 `.toList()` 의 차이점은?
>
> 내 생각에는 `.toList()`가 맞는거 같은데 왜 책에서는 `collect()`를 사용한걸까?
- A. `Stream.toList()` 메서드는 자바 16에 생겼다. 기존에는 `Stream.collect(toList())` 를 사용함. 책에서는 자바 8을 기준으로 설명해야 돼서 `collect()` 메서드를 사용한 것 같다.

## 1-4. 스트림
[통화 필터 예제](https://github.com/StudyRecords/modern-java-in-action/blob/main/src/main/java/ch1/TransactionFilter.java)
- 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 **필터링(filtering)** 하거나 데이터를 **추출(extracting)** 하거나, 데이터를 **그룹화(grouping)** 하는 등의 기능이 있다.
- 컬렉션의 단점과 멀티 스레딩의 단점을 모두 해결하였다.
  - 컬렉션의 단점 : 외부 반복으로 인한 모호함과 반복적인 코드 문제, 멀티 코어 사용 불가능
  - 멀티 스레딩의 단점 : 각각의 스레드는 공유된 데이터에 접근하기 때문에 스레드를 잘 제어하지 못하면 데이터가 바뀔 수 있다.

### 컬렉션 🆚 스트림
- 컬렉션
  - for-each 루프를 이용하여 각 요소를 반복하면서 작업을 수행해야 한다. (외부 반복)
  - 병렬 처리 불가능 (단일 CPU 사용)
  - 어떻게 데이터를 저장하고 접근할지에 중점을 둔다.

- 스트림
  - 스트림 라이브러리 내부에서 모든 데이터가 처리된다. 루프를 신경 쓸 필요가 없다. (내부 반복)
  - 스트림 내의 요소를 쉽게 병렬 처리 가능 (CPU 멀티코어 사용)
  - 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다.


## 1-5. 디폴트 메서드와 자바 모듈
### 모듈
- 자바 9의 모듈 시스템을 통해 패키지 모음을 포함하는 모듈을 정의할 수 있다.
- 모듈을 통해 컴포넌트에 구조를 적용할 수 있다.
- 문서화와 모듈 확인 작업이 용이해졌다.

### 디폴트 메서드 (default method)
- 인터페이스를 쉽게 바꿀 수 있도록 돕는 기능
- 특정 프로그램을 구현하는 데 도움을 주는 기능 (X)
    
  미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능 (O)

- ex. 자바 8 이전 버전은 stream을 지원하지 않는다. 

  → 직접 Collection 인터페이스를 수정 (`stream()` 메서드 추가), 구현 클래스 ArrayList 에서 메서드를 구현

  -> sol) **디폴트 메서드**를 사용하면 인터페이스에 해당 메서드를 추가하고도 구현 클래스에서 구현할 필요가 없다.

- 장점 : 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.

## 1-6. 함수형 프로그래밍에서 가져온 다른 유용한 아이디어
- `Optional<T>` 클래스
  - 값을 갖거나 갖지 않을 수 있는 컨테이너 객체
  - NullPointer 예외를 피할 수 있도록 도와주는 클래스
- (구조적) 패턴 매칭 기법
  - 자바 8은 패턴 매칭을 완벽히 지원하지 X → 스칼라로 패턴 매칭을 사용할 예정