# chapter14

## 배경 :

## 모듈이란??

https://www.oracle.com/kr/corporate/features/understanding-java-9-modules.html 

- 모듈화 기능을 사용하면 패키지보다 상위 단계의 집합(aggregation)을 추가할 수 있음.
- 모듈이란 상호 관련성이 높은, 재사용 가능한 패키지 및 리소스(이미지, XML 파일 등)들을 한데 묶어 지칭하는 명칭

### 모듈 디스크립터

- 해당 모듈의 **이름**
- 해당 모듈의 **종속성**(해당 모듈이 종속되어 있는 다른 모듈들)
- 해당 모듈 내 패키지 중 다른 모듈들이 사용 가능하다고 명시적으로 허용한 것(해당 모듈 내 다른 모든 패키지는 다른 모듈들이 **사용 불가능하다는 암묵적 의미**가 내포되어 있음)
- 해당 모듈이 **제공하는 서비스**
- 해당 모듈이 **사용하는 서비스**
- 해당 모듈이 다른 모듈들의**리플렉션**을 허용하는 요소

![image](https://github.com/KUIT-01-LEGEND/modern-java-in-action/assets/80512150/54558054-f6d7-43cf-ba71-79e854134ede)

- 모듈 디스크립터는 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡술
화할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출시킨다

---

## 추론하기 쉬운 소프트웨어

### 관심사 분리 SoC(separataion of concerns)

- 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙
- 모델，뷰，컨트롤러 같은 아키텍처 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용
- 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업
- 개별 부분을 재사용하기 쉬움
- 전체 시스템을 쉽게 유지보수

### 정보 은닉

- 세부 구현을 숨기도록 장려하는 원칙
- 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다
- 코드를 관리하고 보호하는 데 유용한 원칙
- 자바에선 캡슐화를 통해 정보 은닉 기능 구현 → 하지만 자바 9 이전까지는 클래스와 패키지가 의도된 대로 공개되었는지를 컴파일러로 확인할 수 있는 기능이 없었다

## 모듈화의 한계

### 제한된 가시성 제어

- 자바는 클래스 수준에선 접근자를 통해 가시성을 제어한다. 하지만 패키지 수준에선 이를 제대로 활용할 수 없다. 특정 클래스를 다른 패키지에서 사용하려면 public으로 설계해야 하는데 이 경우, 의도치 않은 패키지에서 접근을 허용하게 된다.
- 내부적으로 사용할 목적으로 만든 구현을 다른 프로그래머가 임시적으로 사용해서 정착해버릴 수 있으므로 결국 기존의 애플리케이션을 망가뜨리지 않고 라이브러리 코드를 바꾸기가 어려워진다.
- 보안 측면에서 볼 때 코드가 노출되었으므로 코드를 임의로 조작하는 위협에 더 많이 노출될 수 있다.

### 클래스 경로 (≠classpath)

- 애플리케이션을 번들하고 실행하는 기능과 관련해 자바는 태생적으로 약점을 갖고 있다. 클래스를 모두 컴파일한 다음 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용 할 수 있다. 그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽는다.
- 안타깝게도 클래스 경로와 JAR 조합에는 몇 가지 약점이 존재한다
1. 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다. 라이브러리 클래스를 지정할 때 버전 1.0을 사용하는지 버전 2.0을 사용하는지 지정할 수가 없으므로 클래스 경로에 두 가지 버전의 같은 라이브러리가 존재할 때 어떤 일이 일어날지 예측할 수 없다.
2. 클래스 경로는 명시적인 의존성을 지원하지 않는다. 클래스 경로만 보고 어떤 일이 발생하는지 파악하기 힘들다. 특히 빠지거나 충돌이 발생하는 의존성이 있는지 알기 힘들다.

### JDK 수준의 문제

- JDK에서 제공하는 라이브러리, 자바API 등 모든 도구들이 애플리케이션에 포함되는 경우가 발생했다. 또한 JDK 내부적으로 사용하는 API 들이 모두 공개되면서, 호환성을 깨뜨리지 않고 관련 API를 수정하기 힘든 상황이 발생했다. 
즉 JDK 자체도 모듈화 할 수 있는 모듈 시스템 설계가 필요했다.

## 모듈 지시어

### requires

- 이 모듈이 다른 모듈에 종속되도록 지정
- 이 관계를 **모듈 종속성**이라고 함
- 모듈 A가 requires 모듈 B 하다면, 모듈 A는 **read** 모듈 B 하고, 모듈 B는 **read by** 모듈 A 하는 관계

`requires **modulename;` ←**모듈명

### exports

- `public` 유형(및 해당 유형에 중첩된 `public` 및 `protected` 유형) 모듈의 여러 패키지 중 하나를 다른 모든 모듈의 코드들이 액세스할 수 있도록 지정
- 내보낸 패키지에 액세스할 수 있는 모듈의 코드를 쉼표로 구분된 목록으로 정확하게 지정할 수 있으며, 이를 **적격(qualified)** 내보내기라고 함

`exports com.example.expenses.readers;` ← 패키지 명

## 모듈 이름 규칙

- 오라클은 패키지명처럼 인터넷 도메인명을 역순（예를 들어 [com.iteratrlearning.training](http://com.iteratrlearning.training) )으로 모듈의 이름을 정하도록 권고한다
- 모듈명은 노출된 주요 API 패키지와 이름이 같아야 한다는 규칙
- 패키지를 포함하지 않거나 어떤 다른 이유로 노출된 패키지 중 하나와 이름이 일치하지 않는 상황을 제외하면 모듈명은 작성자의 인터넷 도메인명을 역순으로 시작해야 한다
