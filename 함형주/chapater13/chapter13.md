# chapter13

## 디폴트 메서드

- 인터페이스에서 제공하는 기본 메서드로 추상메서드와 달리 바디 영역( { } )을 가지고 있으며, 구현 클래스에서 override 하지 않고 인터페이스에서 정의하여 사용할 수 있다. (필요하다면 override 할 수도 있다.)
- 인터페이스에서 디폴트 메서드를 추가하는 것 만으로 해당 인터페이스의 구현 클래스에서 일괄적으로 새로운 기능을 추가하거나 유틸리티 메서드를 제공할 수 있다.
- 즉 디폴트 메서드는 인터페이스와 관련된 호환성 문제를 해결하기 위해 등장했다.

### 바이너리 호환성

- 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황
- 인터페이스에 메서드를 추가하더라도 구현체에서 해당 메서드를 호출하지 않으면 문제 없이 컴파일 될 수 있다(바이너리 호환성). 하지만 구현체를 사용할 일이 있다면 예외가 발생할 것이다.
    
    `Exception in thread "main" java.lang.AbstractMethodError...`, `lambdasinaction/chap9/Ellipse.java:6: error: Ellipse is not abstract and does not
    override abstract method`
    
- 실질적으로 해당 인터페이스를 구현해야 사용할 수 있기에 다른 호환성 문제(소스 호환성)가 발생한다.

### 소스 호환성

- 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일 할 수 있음을 의미
- 인터페이스에 메서드를 추가하면 구현 클래스에서 해당 메서드를 재정의해야 하므로 소스 호환성

### 동작 호환성

- 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다는 의미

→ 추상메서드가 아닌 디폴트 메서드를 사용한다면 호환성을 깨뜨리지 않고 인터페이스에서 기능을 추가할 수 있다.

## 추상 클래스와의 차이점

1. 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스를 여러 개 구현할 수 있다
2. 추상 클래스는 인스턴스 변수(필드)로 공통 상태를 가질 수 있다. 하지만 인터페이스는 인
스턴스 변수를 가질 수 없다
- 상황에 따라 적절히 사용하자.

## 디폴트 메서드의 다중 상속 문제

- 클래스는 여러 인터페이스를 상속 받을 수 있기 때문에 같은 시그니처를 갖는 디폴트 메서드에 대해서 다중 상속 문제가 발생한다고 생각할 수 있다.(다이아몬드 문제) 하지만 이에 대한 몇 가지 규칙이 제한되므로 이에 맞춰 사용한다면 문제 없이 사용할 수 있다.
- 기능이 중복되지 않는 경우는 문제 없다. ex) 인터페이스 A.a(), B.b(), C.c()를 상속 받는 경우

### 규칙

1. 디폴트 메서드를 클래스에서 override 했다면 해당 구현을 따른다.
2. 서브 인터페이스를 사용한다면, 우선권을 갖는다.
아래 두 경우 모두 B.hello() 가 사용된다.

![image](https://github.com/KUIT-01-LEGEND/modern-java-in-action/assets/80512150/9b45dcc2-5965-4dfe-b09b-2231632bd4f8)

1. 위 두 가지로 우선순위가 결정되지 않았다면, 구현 클래스에서 명시적으로 지정해주어야 한다.

![image](https://github.com/KUIT-01-LEGEND/modern-java-in-action/assets/80512150/ceceb17f-4534-486e-861f-4e938f25916d)

- 위 경우에는 디폴트 메서드의 우선순위가 결정되지 않았으므로 `“Error: class C inherits unrelated defaults for hello( ) from types B and A` 같은 에러가 발생한다. 
명시적으로 지정하여 어떤 클래스의 디폴트 메서드를 사용할지 결정할 수 있다.
