## ch4 요약
스트림이 나오기 전까지는 컬렉션을 이용하여 데이터를 지지고 볶고 했는데, 복잡한 처리 과정에서는 코드도 매우 복잡해지고 재사용성도 떨어지며, 성능 개선을 위한 데이터 병렬 처리 코드를 작성하는 것 또한
몹시 힘들었음. 

### 스트림의 등장
#### 무엇을 해결하였는가?
- 선언형으로 코드를 작성 가능 (가독성, 재사용성 증가!)
- 여러 데이터 처리 연산을 파이프라인으로 연결 가능 (가독성, 명확성 증가!)
- 데이터 병렬 처리가 몹시 쉬워짐! (처리 과정이 숨기는 추상화 과정을 통해 가독성 재사용성 증가!)

### 근데 스트림이 뭐지?
정의: 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
특징
- 파이프라이닝: 스트림 연산끼리 연결되어 커다란 파이프라인을 구성함 (게으름, 쇼트서킷 같은 최적화 가능)
- 내부반복

### 컬렉션 vs 스트림
공통점: 
- 모두 연속된 요소형식의 값을 저장하는 자료구조의 인터페이스를 제공

차이점: 
- 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장 ( 모든 요소는 컬렉션에 추가되기 전에 계산되어야 함)
- 스트림은 요청할 때만 요소를 계산함
- 스트림 => 게으르게 만들어진 컬렉션
  
예시: 유튜브 스트리밍과 같은 용어에서 스트림의 역할을 확실히 이해할 수 있음.
유튜브 영상을 한개 시청할때, 영상에 대한 모든 소스들을 저장한 후에 시청 가능 => 컬렉션
현재 보는 영상의 시점에 대한 소스들만 받아오며 시점이 움직이면 해당 움직인 시점에 대한 요청에 응답한 데이터 소스들을 보게 되는 것 => 스트림

### 스트림은 한번만 탐색 가능!
탐색된 스트림 요소들은 소비되어짐.

### 외부 반복 vs 내부 반복

외부반복:
```java
List<String> names = new ArrayList<>();

for(Dish dish: menu){
	names.add(dish.getName());
}
```

내부반복:
```java
List<String> names = menu.stream()
	.map(Dish::getName)
	.collect(toList());
```

컬렉션 인터페이스 이용시 => 외부 반복: 사용자가 직접 요소를 반복함 (반복되는 코드 작성, 가독성 down)
스트림 라이브러리 이용시 => 내부 반복: 어떤 작업 수행할지 지정만 하면 알아서 처리가 됨. (추상성 up! 가독성 up! 재사용성 up!)


### 스트림 연산
#### 중간 연산
=> 연결할 수 있는 스트림 연산
단말 연산을 스트림 파이프 라인에 실행하기 전까지는 아무 연산도 수행하지 않는다. => 게으르다 => 여러 최적화 효과 얻을 수 있다.
#### 최종 연산
=> 스트림을 닫는 연산
스트림 파이프라인에서 겨롹를 도출
